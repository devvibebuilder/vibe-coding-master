# .cursorrules - Reglamento Constitucional del Repositorio (v4.0.0)

## 1. GOBERNANZA DE DIRECTORIOS Y ADN DEL PROYECTO
- **Aislamiento Estricto de Capas:**
    - `/logic`: Solo lógica de negocio central y entidades de dominio. Funciones puras, agnósticas al framework.
    - `/interfaces`: Contratos, esquemas de validación y definiciones de datos. El "Qué", no el "Cómo".
    - `/adapters`: Implementaciones de infraestructura (Bases de datos, Clientes API, UI, Frameworks).
    - `/specs`: Documentación técnica, Business Case y Decisiones Arquitectónicas (ADRs).
    - `/tests`: Estructura de pruebas espejo a la fuente (Unitarias en Logic, Integración en Adapters).
    - `/audit`: Logs de seguridad, trazabilidad de decisiones y cumplimiento técnico.

## 2. PROTOCOLO DE EJECUCIÓN SISTEMÁTICA
Antes de generar código, el agente debe documentar su proceso de pensamiento:
1. **Mapeo de Contexto:** Verificar contratos en `/interfaces` antes de implementar en `/adapters`.
2. **Análisis de Trade-off:** Justificar la elección de patrones según el lenguaje (ej. Protocolos en Swift, Interfaces en Go, Types en TS).
3. **Validación Adversarial:** Evaluar fallos potenciales en la frontera de datos.

## 3. REGLAS ESPECÍFICAS PARA /INTERFACES (POLÍGLOTA)
1. **Esquemas de Validación Obligatorios:** Toda interfaz debe usar un motor de validación de esquemas nativo o estándar del stack (ej. Zod para TS, Pydantic para Python, Serde para Rust, Marshmallow para Flask).
2. **Fuente Única de Verdad:** Los tipos de datos o estructuras deben derivarse de los esquemas de validación para evitar discrepancias.
3. **Validación en la Frontera:** El agente DEBE validar los datos en los `/adapters` usando los contratos de `/interfaces` antes de permitir que la información llegue a la capa de `/logic`.
4. **Nomenclatura Sugerida:** `[entidad].schema.[ext]` o `[entidad].contract.[ext]`.

## 4. RESTRICCIONES TÉCNICAS UNIVERSALES
- **Tipado Estricto:** Prohibido el uso de tipos genéricos no descriptivos (ej. `any`, `Object`, `void*`).
- **Manejo de Errores:** Preferir patrones de retorno de error (Result/Either/Errors) sobre excepciones para el flujo lógico.
- **Límites de Complejidad:** Funciones < 20 líneas. Máximo 3 argumentos por función para asegurar la modularidad.
- **Nomenclatura:** Funciones iniciadas con verbos. Booleans con prefijos indicativos (is, has, can).

## 5. SEGURIDAD Y GOBERNANZA DE DATOS
- **Sanitización Obligatoria:** Limpiar entradas en la capa de Adapter. Prevenir inyecciones según el stack tecnológico.
- **Secretos Cero:** Prohibido el hardcoding de llaves. Uso mandatorio de variables de entorno o gestores de secretos.
- **Trazabilidad:** Operaciones críticas deben generar un registro en `/audit`.

## 6. LIDERAZGO ACTIVO Y AMBIGÜEDAD
- Si falta profundidad técnica o el usuario intenta codificar sin definir el negocio:
    1. **Bloqueo Preventivo:** No avanzar a `/logic` sin la aprobación de `specs/plantilla_vision.md`.
    2. **Entrevista Socrática:** Preguntar por Entidades, Adapters y Flujos de Datos.

## 7. DOCUMENTACIÓN Y VERSIONADO
- **Estándares:** Comentarios descriptivos según el lenguaje (Docstrings, JSDoc, Rustdoc).
- **Git Flow:** Uso de Conventional Commits (feat, fix, refactor, chore).
- **Auditoría de Contratos:** Antes de finalizar, el agente debe verificar que la implementación en Adapters sea fiel al contrato en Interfaces.
